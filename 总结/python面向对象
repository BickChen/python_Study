编程范式主流的是两种：
面向过程编程：
面向过程的程序设计的核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的设计就好比精心设计好一条流水线，
考虑周全什么时候处理什么东西。
优点是：极大的降低了写程序的复杂度，只需要顺着要执行的步骤，堆叠代码即可。
缺点是：一套流水线或者流程就是用来解决一个问题，代码牵一发而动全身。

面向对象编程：
优点是：解决了程序的扩展性。对某一个对象单独修改，会立刻反映到整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易。
缺点：可控性差，无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，
面向对象的程序一旦开始就由对象之间的交互解决问题，即便是上帝也无法预测最终结果。
于是我们经常看到一个游戏人某一参数的修改极有可能导致阴霸的技能出现，一刀砍死3个人，这个游戏就失去平衡。

self就是代表实例本身。你实例化时python会自动把这个实例本身通过self参数传进去。

(Class)类
一个类即是对一类拥有相同属性的对象的抽象、蓝图、原型。在类中定义了这些对象的都具备的属性（variables(data)）、共同的方法
(Object)对象
一个对象即是一个类的实例化后实例，一个类必须经过实例化后方可在程序中调用，一个类可以实例化多个对象，每个对象亦可以有不同的属性
就像人类是指所有人，每个人是指具体的对象，人与人之前有共性，亦有不同
(Encapsulation)封装
在类中对数据的赋值、内部调用对外部用户是透明的，这使类变成了一个胶囊或容器，里面包含着类的数据和方法
(Inheritance)继承
一个类可以派生出子类，在这个父类里定义的属性、方法自动被子类继承
(Polymorphism)多态
多态是面向对象的重要特性,简单点说:“一个接口，多种实现”，指一个基类中派生出了不同的子类，
且每个子类在继承了同样的方法名的同时又对父类的方法做了不同的实现，这就是同一种事物表现出的多种形态。

类与类之间的关系：
依赖关系，狗和主人的关系
关联关系，你和你的女盆友的关系就是关联关系
组合关系，比聚合还要紧密.比如人的大脑, 心脏, 各个器官. 这些器官组合成一个人. 这时. 人如果挂了. 其他的东西也跟着挂了
聚合关系，电脑的各部件组成完整的电脑，电脑里有CPU, 硬盘, 内存等。 每个组件有自己的生命周期， 电脑挂了. CPU还是好的.
还是完整的个体
继承关系， 类的三大特性之一，子承父业

当类之间有显著不同，并且较小的类是较大的类所需要的组件时，用组合比较好

继承与抽象（先抽象再继承)
抽象最主要的作用是划分类别（可以隔离关注点，降低复杂度）
继承：是基于抽象的结果，通过编程语言去实现它，肯定是先经历抽象这个过程，才能通过继承的方式去表达出抽象的结构。
继承的优点也是显而易见的：
1，增加了类的耦合性。
2，减少了重复代码。
3，使得代码更加规范化，合理化。
继承的分类
（Aminal）叫做父类,基类,超类。
（Person）Pig Dog: 子类，派生类。
继承：可以分单继承，多继承。

继承的查找顺序有两种规则
深度优先：从左到右查找继承的类，先查找左边上层的再查找右边上层的。
广度优先：从左到右查找继承的类，先查找完平级的继承类，在查找上层的继承类。

在Python 中，有2种类的写法， 不同写法的采用的继承顺序不同
class A: # 经典类
    pass
class B(object): # 新式类
    pass
在python 2中，经典类采用的是深度优先查找法， 新式类采用的是广度优先
在python 3中，无论是经典类，还是新式类，都是按广度优先查找，严格来说python3的查找顺序是根据C3算法来查找的。
print(F.__mro__) # 打印类的继承顺序

封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。
要访问该类的代码和数据，必须通过严格的接口控制。
封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。
适当的封装可以让程式码更容易理解与维护，也加强了代码数据的安全性。
封装的优点：
1. 良好的封装能够减少耦合。
2. 类内部的结构可以自由修改。
3. 可以对成员变量进行更精确的控制。
4. 隐藏信息，实现细节。
【封装原则】
1. 将不需要对外提供的内容都隐藏起来；
2. 把属性都隐藏，提供公共方法对其访问。

