作为应用开发程序员，我们开发的软件都是应用软件，而应用软件必须运行于操作系统之上，
操作系统则运行于硬件之上，应用软件是无法直接操作硬件的，
应用软件对硬件的操作必须调用操作系统的接口，由操作系统操控硬件。

比如客户端软件想要基于网络发送一条消息给服务端软件，流程是：
1、客户端软件产生数据，存放于客户端软件的内存中，然后调用接口将自己内存中的数据发送／拷贝给操作系统内存
2、客户端操作系统收到数据后，按照客户端软件指定的规则（即协议）、调用网卡发送数据
3、网络传输数据
4、服务端软件调用系统接口，想要将数据从操作系统内存拷贝到自己的内存中
5、服务端操作系统收到4的指令后，使用与客户端相同的规则（即协议）从网卡接收到数据，然后拷贝给服务端软件

以太网协议：
早期的时候各个公司都有自己的分组方式，后来形成了统一的标准，即以太网协议ethernet
ethernet规定
一组电信号构成一个数据包，叫做‘帧’
每一数据帧分成：报头head和数据data两部分
head data
head包含：(固定18个字节)
发送者／源地址，6个字节
接收者／目标地址，6个字节
数据类型，6个字节
data包含：(最短46字节，最长1500字节)
数据包的具体内容
head长度＋data长度＝最短64字节，最长1518字节，超过最大限制就分片发送

mac地址：
head中包含的源和目标地址由来：ethernet规定接入internet的设备都必须具备网卡，发送端和接收端的地址便是指网卡的地址，即mac地址
mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示
（前六位是厂商编号，后六位是流水线号）

广播：
有了mac地址，同一网络内的两台主机就可以通信了（一台主机通过arp协议获取另外一台主机的mac地址）
ethernet采用最原始的方式，广播的方式进行通信，即计算机通信基本靠吼

IP地址分类：
IP地址根据网络ID的不同分为5种类型，A类地址、B类地址、C类地址、D类地址和E类地址。
A类IP地址：一个A类IP地址由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”， 地址范围从1.0.0.0 到126.0.0.0。可用的A类网络有126个，每个网络能容纳1亿多个主机。
B类IP地址 ：一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，地址范围从128.0.0.0到191.255.255.255。可用的B类网络有16382个，每个网络能容纳6万多个主机 。
C类IP地址：一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”。范围从192.0.0.0到223.255.255.255。C类网络可达209万余个，每个网络能容纳254个主机。
D类地址用于多点广播（Multicast）： D类IP地址第一个字节以“lll0”开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。
E类IP地址 以“llll0”开始，为将来使用保留。
全零（“0．0．0．0”）地址对应于当前主机。全“1”的IP地址（“255．255．255．255”）是当前子网的广播地址。
回环地址(127.0.0.1) 又称为本机地址，那它跟0.0.0.0是什么区别呢？那得先了解回环接口

回环地址(127.0.0.1) 又称为本机地址，那它跟0.0.0.0是什么区别呢？那得先了解回环接口
环回接口（loopback）。平时我们用127.0.0.1来尝试自己的机器服务器好使不好使。走的就是这个loopback接口。
对于环回接口，有如下三点值得注意:
传给环回地址（一般是127.0.0.1）的任何数据均作为IP输入。
传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。这是 因为广播传送和多播传送的定义包含主机本身。
任何传给该主机IP地址的数据均送到环回接口

TCP协议虽然安全性很高，但是网络开销大，
而UDP协议虽然没有提供安全机制，但是网络开销小，
在现在这个网络安全已经相对较高的情况下，为了保证传输的速率，我们一般还是会优先考虑UDP协议！

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。
在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部。


tcp基于链接通信
基于链接，则需要listen（backlog），指定连接池的大小
基于链接，必须先运行的服务端，然后客户端发起链接请求
对于mac系统：如果一端断开了链接，那另外一端的链接也跟着完蛋recv将不会阻塞，收到的是空(解决方法是：服务端在收消息后加上if判断，空消息就break掉通信循环)
对于windows/linux系统：如果一端断开了链接，那另外一端的链接也跟着完蛋recv将不会阻塞，收到的是空(解决方法是：服务端通信循环内加异常处理，捕捉到异常后就break掉通讯循环)

udp无链接
无链接，因而无需listen（backlog），更加没有什么连接池之说了
无链接，udp的sendinto不用管是否有一个正在运行的服务端，可以己端一个劲的发消息，只不过数据丢失
recvfrom收的数据小于sendinto发送的数据时，在mac和linux系统上数据直接丢失，在windows系统上发送的比接收的大直接报错
只有sendinto发送数据没有recvfrom收数据，数据丢失
