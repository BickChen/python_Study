重要：
1、cpu到底是用来做计算的，还是用来做I/O的？
2、多cpu，意味着可以有多个核并行完成计算，所以多核提升的是计算性能
3、每个cpu一旦遇到I/O阻塞，仍然需要等待，所以多核对I/O操作没什么用处
多线程用于IO密集型，如socket，爬虫，web
多进程用于计算密集型，如金融分析


进程即正在执行的一个过程。进程是对正在运行程序的一个抽象。
一 操作系统的作用：
1：隐藏丑陋复杂的硬件接口，提供良好的抽象接口
2：管理、调度进程，并且将多个进程对硬件的竞争变得有序
二 多道技术：
1.产生背景：针对单核，实现并发
ps：
现在的主机一般是多核，那么每个核都会利用多道技术
有4个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到4个
cpu中的任意一个，具体由操作系统调度算法决定。
2.空间上的复用：如内存中同时有多道程序
3.时间上的复用：复用一个cpu的时间片
   强调：遇到io切，占用cpu时间过长也切，核心在于切之前将进程的状态保存下来，这样
        才能保证下次切换回来时，能基于上次切走的位置继续运行

进程：正在进行的一个过程或者说一个任务。而负责执行任务则是cpu。
程序仅仅只是一堆代码而已，而进程指的是程序的运行过程。

无论是并行还是并发，在用户看来都是’同时’运行的，不管是进程还是线程，都只是一个任务而已，真是干活的是cpu，cpu来做这些任务，而一个cpu同一时刻只能执行一个任务
一 并发：是伪并行，即看起来是同时运行。单个cpu+多道技术就可以实现并发
举例（单核+多道，实现多个进程的并发执行）：
egon在一个时间段内有很多任务要做：python备课的任务，写书的任务，交女朋友的任务，王者荣耀上分的任务，
但egon同一时刻只能做一个任务（cpu同一时间只能干一个活），如何才能玩出多个任务并发执行的效果？
egon备一会课，再去跟李杰的女朋友聊聊天，再去打一会王者荣耀….这就保证了每个任务都在进行中.
二 并行：同时运行，只有具备多个cpu才能实现并行
单核下，可以利用多道技术，多个核，每个核也都可以利用多道技术（多道技术是针对单核而言的）
有四个核，六个任务，这样同一时间有四个任务被执行，假设分别被分配给了cpu1，cpu2，cpu3，cpu4，
一旦任务1遇到I/O就被迫中断执行，此时任务5就拿到cpu1的时间片去执行，这就是单核下的多道技术
而一旦任务1的I/O结束了，操作系统会重新调用它(需知进程的调度、分配给哪个cpu运行，由操作系统说了算)
可能被分 配给四个cpu中的任意一个去执行

进程的层次结构
在UNIX中所有的进程，都是以init进程为根，组成树形结构。
父子进程共同组成一个进程组，这样，当从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员。
在windows中，没有进程层次的概念，所有的进程都是地位相同的，
唯一类似于进程层次的暗示，是在创建进程时，父进程得到一个特别的令牌（称为句柄）,
该句柄可以用来控制子进程，但是父进程有权把该句柄传给其他子进程，这样就没有层次了。

进程并发的实现在于，硬件中断一个正在运行的进程，把此时进程运行的所有状态保存下来，
为此，操作系统维护一张表格，即进程表（process table），每个进程占用一个进程表项（这些表项也称为进程控制块）

守护进程需要强调两点：
其一：守护进程会在主进程代码执行结束后就终止
其二：守护进程内无法再开启子进程,否则抛出异常：
AssertionError: daemonic processes are not allowed to have children

进程彼此之间互相隔离，要实现进程间通信（IPC），multiprocessing模块支持两种形式：队列和管道，这两种方式都是使用消息传递的
生产者消费者模型总结：
1、程序中有两类角色
一类负责生产数据（生产者）
一类负责处理数据（消费者）
2、引入生产者消费者模型为了解决的问题是
平衡生产者与消费者之间的速度差
程序解开耦合
3、如何实现生产者消费者模型
生产者<--->队列<--->消费者


特定的场景下需要使用多线程的原因：
1、同一个进程内的多个线程共享该进程内的地址资源
2、创建线程的开销要远小于创建进程的开销
（创建一个进程，就是创建一个车间，涉及到申请空间，而且在该空间内建至少一条流水线，
但创建线程，就只是在一个车间内造一条流水线，无需申请空间，所以创建开销小）

1、主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,
然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束，
2、主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。
因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。

死锁： 是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，
若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁。
解决方法，递归锁，在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。
这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。
直到一个线程所有的acquire都被release，其他的线程才能获得资源。

进程池或线程池内的每个进程或线程绑定一个函数，该函数在进程或线程的任务执行完毕后自动触发，并接收任务的返回值当作参数，该函数称为回调函数

协程的本质就是在单线程下，由用户自己控制一个任务遇到io阻塞了就切换另外一个任务去执行，以此来提升效率。
协程：是单线程下的并发，又称微线程，纤程。英文名Coroutine。一句话说明什么是协程：
协程是一种用户态的轻量级线程，即协程是由用户程序自己控制调度的。
优点如下：
1. 协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级
2. 单线程内就可以实现并发的效果，最大限度地利用cpu
缺点如下：
1. 协程的本质是单线程下，无法利用多核，可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协程
2. 协程指的是单个线程，因而一旦协程出现阻塞，将会阻塞整个线程
注意：
1. python的线程属于内核级别的，即由操作系统控制调度（如单线程遇到io或执行时间过长就会被迫交出cpu执行权限，切换其他线程运行）
2. 单线程内开启协程，一旦遇到io，就会从应用程序级别（而非操作系统）控制切换，以此来提升效率（！！！非io操作的切换与效率无关）

总结协程特点：
1、必须在只有一个单线程里实现并发
2、修改共享数据不需加锁
3、用户程序里自己保存多个控制流的上下文栈
附加：一个协程遇到IO操作自动切换到其它协程（如何实现检测IO，yield、greenlet都无法实现，就用到了gevent模块（select机制））


